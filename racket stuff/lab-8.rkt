(define (create-heap v H1 H2)
  (list v H1 H2))
(define (h-min H) (car H)) ; (v) -> (H1 H2)
(define (left H) (cadr H)) ; (H1) -> (H2)
(define (right H) (caddr H)) ; (H2)
(define (combine-heaps H1 H2)
  (cond ((null? H1) H2)
        ((null? H2) H1)
        ((< (h-min H1) (h-min H2))
         (create-heap (h-min H1)
                      (combine-heaps (left H1) (right H1))
                      H2))
        (else
         (create-heap (h-min H2)
                      (combine-heaps (left H2) (right H2))
                      H1))))

(define (heap-insert f x H)
  (if (null? H)
      (create-heap x '() '())
      (let ((child-value (max x (h-min H)))
            (root-value (min x (h-min H))))
        (if (equal? f >)
            (create-heap child-value (right H)
            (heap-insert f root-value (left H)))
            (create-heap root-value (right H)
            (heap-insert f child-value (left H)))))))

(define (combine f Ha Hb)
  (cond ((null? Ha) Hb)
        ((null? Hb) Ha)
        ((f (h-min Ha) (h-min Hb))
         (create-heap (h-min Ha) Hb (combine f (left Ha) (right Ha))))
        (else (create-heap (h-min Hb) Ha
                           (combine f (left Hb)
                           (right Hb)) ))))
(combine < '(0 (3 (8 () ()) (6 () (19 () ())))(1 (14 () (17 () ())) (2 () (5 () ())))) '(9 (42 () (64 () ())) (15 (99 () ()) (89 () ()))))
(define (empty? H)
  (null? H))

(define (heap-remove f H)
  (combine f (left H) (right H)))

            