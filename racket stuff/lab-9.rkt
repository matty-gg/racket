(define (create-heap v H1 H2)
  (list v H1 H2))
(define (h-min H) (car H)) ; (v) -> (H1 H2)
(define (left H) (cadr H)) ; (H1) -> (H2)
(define (right H) (caddr H)) ; (H2)
(define (combine-heaps H1 H2)
  (cond ((null? H1) H2)
        ((null? H2) H1)
        ((< (h-min H1) (h-min H2))
         (create-heap (h-min H1)
                      (combine-heaps (left H1) (right H1))
                      H2))
        (else
         (create-heap (h-min H2)
                      (combine-heaps (left H2) (right H2))
                      H1))))

(define (heap-insert f x H)
  (if (null? H)
      (create-heap x '() '())
      (let ((child-value (max x (h-min H)))
            (root-value (min x (h-min H))))
        (if (equal? f >)
            (create-heap child-value (right H)
            (heap-insert f root-value (left H)))
            (create-heap root-value (right H)
            (heap-insert f child-value (left H)))))))

(define (combine f Ha Hb)
  (cond ((null? Ha) Hb)
        ((null? Hb) Ha)
        ((f (h-min Ha) (h-min Hb))
         (create-heap (h-min Ha) Hb (combine f (left Ha) (right Ha))))
        (else (create-heap (h-min Hb) Ha
                           (combine f (left Hb)
                           (right Hb)) ))))
(define (empty? H)
  (null? H))

(define (heap-remove f H)
  (combine f (left H) (right H)))

(define (heap-count h)
  (cond ((null? h) 0)
        (else (+ 1
                 (heap-count (left h))
                 (heap-count (right h))))))
;PROBLEM A
(define (equalize-heaps heap-pair)
  (let ((h1 (cdr (car heap-pair)))
        (h2 (cdr (cdr heap-pair)))
        (first (car (car heap-pair)))
        (second (car (cdr heap-pair))))
    (if (> (abs (- first second)) 1)
        (if (> first second)
            (equalize-heaps (cons (cons (- first 1) (heap-remove > h1))
            (cons (+ second 1) (heap-insert < (h-min h1) h2))) )
            (equalize-heaps (cons (cons (+ first 1) (heap-insert > (h-min h2) h1))
            (cons (- second 1) (heap-remove < h2)))))
        heap-pair)))
;PROBLEM B
(define (add-number x heap-pair)
  (let ((h1 (cdr (car heap-pair)))
        (h2 (cdr (cdr heap-pair)))
        (first (car (car heap-pair)))
        (second (car (cdr heap-pair))))
    (cond ((< x (h-min (cdar heap-pair)))
           (equalize-heaps (cons (cons (+ (caar heap-pair) 1) (heap-insert > x (cdar heap-pair))) (cdr heap-pair))))
          (else
           (equalize-heaps (cons (car heap-pair) (cons  (+ (cadr heap-pair) 1) (heap-insert < x (cddr heap-pair))) ))))))
;PROBLEM C
(define (get-median heap-pair)
  (let ((eq (equalize-heaps heap-pair)))
    (if (not (eq? (caar eq) (cadr eq)))
               (if (> (caar eq) (cadr eq))
                   (h-min (cdar eq))
                   (h-min (cddr eq)))
            (/ (+ (h-min (cdar eq)) (h-min (cddr eq))) 2))))

(get-median '((4 4 (3 (1 () ()) ()) (2 () ())) 4 5 (6 (8 () ()) ()) (7 () ())))
        